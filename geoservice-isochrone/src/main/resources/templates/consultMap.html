<!DOCTYPE html>
<html lang="fr" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity6">
<head th:insert="~{fragments/fragment-head :: head}"></head>
<body class="sb-nav-fixed">
<div th:insert="~{fragments/fragment-navUp :: navUp}"></div>
<div id="layoutSidenav">
  <div th:insert="~{fragments/fragment-navLeft :: navLeft}"></div>
  <div id="layoutSidenav_content">
    <main>
      <div class="container-fluid">
        <h4 class="mt-3">Consultation Cartographique</h4>
        <p class="text-muted">Vue lecture seule pour explorer les différentes couches géographiques (fonds de carte et données GeoJSON). Sélectionnez la région, la communauté de communes puis la commune pour centrer automatiquement la carte. Les couches se rechargent automatiquement selon le cadre visible.</p>

        <!-- Sélecteurs territoriaux -->
        <div class="row g-2 mb-2">
          <div class="col-12 col-md-3">
            <form id="formSelectRegion" th:action="@{/mvc/consult/region}" method="post" onchange="submit();">
              <div class="form-floating">
                <select class="form-select" id="idRegion" name="idRegion">
                  <option value="" selected disabled>Région...</option>
                  <option th:each="r : ${regions}" th:value="${r.id}" th:text="${r.name}" th:selected="${territoire != null && r.id == territoire.idRegion}"></option>
                </select>
                <label for="idRegion">Région</label>
              </div>
            </form>
          </div>
          <div class="col-12 col-md-3">
            <form id="formSelectComm2co" th:action="@{/mvc/consult/epci}" method="post" onchange="submit();">
              <fieldset id="fsComm2co" th:disabled="${territoire == null || territoire.idRegion == null}">
                <div class="form-floating">
                  <select class="form-select" id="idCommunauteDeCommunes" name="idCommunauteDeCommunes">
                    <option value="">EPCI...</option>
                    <option th:each="c : ${communautesDeCommunes}" th:value="${c.id}" th:text="${c.name}" th:selected="${territoire != null && c.id == territoire.idCommunauteDeCommunes}"></option>
                  </select>
                  <label for="idCommunauteDeCommunes">Communauté de communes</label>
                  <input type="hidden" id="idRegion" name="idRegion" th:value="${territoire != null ? territoire.idRegion : ''}" />
                </div>
              </fieldset>
            </form>
          </div>
          <div class="col-12 col-md-3">
            <form id="formSelectCity" th:action="@{/mvc/consult/city}" method="post">
              <fieldset id="fsCity" th:disabled="${territoire == null || territoire.idCommunauteDeCommunes == null}">
                <div class="form-floating">
                  <input class="form-control" list="communes" id="idCommune-filter" name="idCommune-filter" placeholder="Commune..." 
                         th:value="${territoire != null && territoire.nameCommune != null ? territoire.nameCommune : ''}" />
                  <label for="idCommune-filter">Commune</label>
                  <datalist id="communes">
                    <option th:each="v : ${communes}" th:value="${v.name}" th:attr="data-value=${v.id}"></option>
                  </datalist>
                  <input type="hidden" id="idCommune" name="idCommune" th:value="${territoire != null && territoire.idCommune != null ? territoire.idCommune : ''}" />
                  <input type="hidden" id="idRegionCity" name="idRegion" th:value="${territoire != null && territoire.idRegion != null ? territoire.idRegion : ''}" />
                  <input type="hidden" id="idCommunauteDeCommunesCity" name="idCommunauteDeCommunes" th:value="${territoire != null && territoire.idCommunauteDeCommunes != null ? territoire.idCommunauteDeCommunes : ''}" />
                </div>
              </fieldset>
            </form>
          </div>
          <!-- Rien ici, le select des couches est déplacé dans la carte -->
        </div>

        <!-- Carte -->
        <div class="row">
          <div class="col-12">
            <div style="text-align: end; margin-bottom: 10px;">
              Localiser dans <a id="aGMapLink" href="#" target="_blank" rel="noopener noreferrer" alt="voir la même carte sur GMap">Google Map</a>
            </div>
            <div class="card" style="position:relative;">
              <div id="mapConsult" style="width:100%; height:calc(100vh - 250px);"></div>
              <!-- Le contrôle des couches est géré par Leaflet Layers -->
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>
</div>

<div th:insert="~{fragments/fragment-footer :: footer}"></div>
<div th:insert="~{fragments/fragment-jslibs :: newMap}"></div>
<script th:src="@{/mvc/static/js/scripts.js}"></script>

<script th:inline="javascript">
// ----------- INITIALISATION TERRITOIRE (datalist commune) -----------
const hasTerritoire = /*[[${territoire != null}]]*/ false;
let latTpl = null, lonTpl = null;
if (hasTerritoire) {
  latTpl = /*[[${territoire.lat}]]*/ null;
  lonTpl = /*[[${territoire.lon}]]*/ null;
}
(function initCommuneDatalist(){
  const input = document.getElementById('idCommune-filter');
  if (!input) return;
  
  console.log('[ConsultMap] Init datalist commune, hasTerritoire:', hasTerritoire);
  
  input.addEventListener('input', function(e){
    const options = document.querySelectorAll('#communes option');
    const hiddenInput = document.getElementById('idCommune');
    const inputValue = e.target.value;
    
    console.log('[ConsultMap] Input commune changed:', inputValue);
    
    hiddenInput.value = ''; // reset
    
    for (const o of options){
      if (o.value === inputValue) {
        const dataValue = o.getAttribute('data-value');
        hiddenInput.value = dataValue;
        console.log('[ConsultMap] Commune trouvée, id:', dataValue);
        document.getElementById('formSelectCity').submit();
        break;
      }
    }
  });
})();

// ----------- FONDS DE CARTE -----------
const mapMinZoom=13, mapMaxZoom=18;
const layerOSM = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; <a target="_blank" rel="noopener" href="http://osm.org/copyright">OpenStreetMap</a> contributors',
  maxZoom: mapMaxZoom,minZoom: mapMinZoom
});
const layerWorldStreet = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Esri World Street Map', maxZoom: mapMaxZoom, minZoom: mapMinZoom
});
const layerSatellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Esri Satellite', maxZoom: mapMaxZoom, minZoom: mapMinZoom
});
const layerAeroIgn = L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE=normal&TILEMATRIXSET=PM&FORMAT=image/jpeg&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS', {
  attribution: 'IGN GeoPortail', maxZoom: Math.min(18,mapMaxZoom), minZoom: mapMinZoom
});
const baseLayers = { 'IGN Aérien': layerAeroIgn, 'Satellite': layerSatellite, 'WorldStreet': layerWorldStreet, 'OpenStreetMap': layerOSM };

// ----------- MAP -----------
let center = L.latLng(50.626419,3.0719121); // défaut
if (latTpl !== null && lonTpl !== null) { center = L.latLng(latTpl, lonTpl); }

// ----------- OVERLAYS DYNAMIQUES (dataLayers comme newPark.html) -----------
const dataParcs = L.layerGroup();
const dataCarre = L.layerGroup();
const dataIris = L.layerGroup();
const dataCadastre = L.layerGroup();
const dataVegetation = L.layerGroup();
const dataLayers = {
  'Parcs': dataParcs,
  'Carrés': dataCarre,
  'IRIS': dataIris,
  'Cadastre': dataCadastre,
  'Végétation IGN': dataVegetation
};

console.log('[ConsultMap] Initialisation carte...');
const map = L.map('mapConsult', { zoom: 13, layers: [layerOSM, dataParcs] }).setView(center);
console.log('[ConsultMap] Carte initialisée:', map);
L.control.scale().addTo(map);
const layerControl = L.control.layers(baseLayers, dataLayers).addTo(map);
console.log('[ConsultMap] LayerControl ajouté avec dataLayers:', dataLayers);

function computeBoundsQuery(){
  const b = map.getBounds();
  return `swLat=${b.getSouthWest().lat}&swLng=${b.getSouthWest().lng}&neLat=${b.getNorthEast().lat}&neLng=${b.getNorthEast().lng}`;
}

// Endpoints Thymeleaf (remplacés serveur)
const endpointParcs = /*[[@{/mvc/geojson/parkGardenOutlineByCorner}]]*/ '';
const endpointCarre = /*[[@{/mvc/geojson/carreByCorner}]]*/ '';
const endpointIris = /*[[@{/mvc/geojson/irisByCorner}]]*/ '';
const endpointCadastre = /*[[@{/mvc/geojson/cadastreByCorner}]]*/ '';
const endpointVegetation = 'https://raw.githubusercontent.com/autmel/geoservice-data/refs/heads/main/stats/vegetalInseeIgnTopo.json';
const urlEditPark = /*[[@{/mvc/park/new/check}]]*/ '/mvc/park/new/check';

// Styles ajustés pour accentuer le contraste bordure/fond tout en conservant une bordure fine
// - Couleur de bordure plus sombre
// - fillColor plus claire que la bordure
// - fillOpacity légèrement augmentée pour lisibilité sans masquer le fond
// - weight maintenu à 1 (ou réduit depuis 2) pour rester fin
const overlayConfig = {
  'Parcs': { endpoint: endpointParcs, style: { color:'#1e4d1c', fillColor:'#3aa637', weight:1, fillOpacity:0.35 } },
  'Carrés': { endpoint: endpointCarre, style: { color:'#002a99', fillColor:'#3385ff', weight:1, fillOpacity:0.25 } },
  'IRIS': { endpoint: endpointIris, style: { color:'#b85f00', fillColor:'#ff9d33', weight:1, fillOpacity:0.25 } },
  // Cadastre dynamique: rechargé à chaque mouvement avec cache et debounce
  'Cadastre': { endpoint: endpointCadastre, style: { color:'#7a7c00', fillColor:'#d6d900', weight:1, fillOpacity:0.18 } },
  'Végétation IGN': { endpoint: endpointVegetation, style: { color:'#0f4d0f', fillColor:'#2fa42f', weight:1, fillOpacity:0.45 }, static: true }
};
console.log('[ConsultMap] overlayConfig:', overlayConfig);

// Cache conditionnel
const lastBounds = {}; // pour couches dynamiques
const loadedStatic = {}; // pour couches statiques (chargées une seule fois)
const staticTimers = {}; // timers de délai unique
const pendingFetches = {}; // suivi des requêtes en cours pour éviter les doublons
const EXPAND_RATIO = 0.3;
function expandBounds(b){
  const sw = b.getSouthWest();
  const ne = b.getNorthEast();
  const latPad = (ne.lat - sw.lat) * EXPAND_RATIO;
  const lngPad = (ne.lng - sw.lng) * EXPAND_RATIO;
  return L.latLngBounds(
    L.latLng(sw.lat - latPad, sw.lng - lngPad),
    L.latLng(ne.lat + latPad, ne.lng + lngPad)
  );
}

function updateGeojsonLayer(name) {
  const cfg = overlayConfig[name];
  const group = dataLayers[name];
  if (!map.hasLayer(group)) return;

  // Static layer: fetch only once (with optional delay)
  if (cfg.static) {
    if (loadedStatic[name]) return; // already loaded
    if (staticTimers[name]) return; // timer pending
    const doLoad = () => {
      staticTimers[name] = null;
      const fetchLabel = `[${name}] fetch`;
      const parseLabel = `[${name}] parse`;
      const renderLabel = `[${name}] render`;
      console.time(fetchLabel);
      fetch(cfg.endpoint)
        .then(r => { console.timeEnd(fetchLabel); console.time(parseLabel); return r.json(); })
        .then(geo => {
          console.timeEnd(parseLabel); console.time(renderLabel);
          const gj = L.geoJSON(geo, {
            style: cfg.style,
            onEachFeature: (feat, layer) => {
              if (feat.properties){
                const nm = feat.properties.name || feat.properties.nom || name;
                let popupContent = `<strong>${nm}</strong>`;
                // Ajouter un lien d'édition pour les parcs
                if (name === 'Parcs' && feat.properties.id) {
                  const sUrlEditPark = window.location.protocol + "//" + window.location.host + urlEditPark + '?idPark=';
                  popupContent += `<p><a href='${sUrlEditPark}${feat.properties.id}'>Éditer</a></p>`;
                }
                // Ajouter id et surface pour la Végétation IGN
                if (name === 'Végétation IGN') {
                  if (feat.id) {
                    popupContent += `<p>ID: ${feat.id}</p>`;
                  }
                  if (feat.properties.surface) {
                    const surface = parseFloat(feat.properties.surface);
                    if (surface >= 10000) {
                      const hectares = (surface / 10000).toFixed(2);
                      popupContent += `<p>Surface: ${hectares} ha</p>`;
                    } else {
                      const m2 = Math.round(surface);
                      popupContent += `<p>Surface: ${m2} m²</p>`;
                    }
                  }
                  if (feat.properties.nature) {
                    popupContent += `<p>Nature: ${feat.properties.nature}</p>`;
                  }
                }
                layer.bindPopup(popupContent);
              }
            }
          });
          console.timeEnd(renderLabel);
          group.addLayer(gj);
          loadedStatic[name] = true;
          console.log(`[ConsultMap][${name}] Chargé (static)`);
        })
        .catch(err => {
          console.warn('Erreur chargement couche static', name, err);
          console.timeEnd(fetchLabel); console.timeEnd(parseLabel); console.timeEnd(renderLabel);
        });
    };
    const delay = cfg.loadDelay || 0;
    if (delay > 0) {
      staticTimers[name] = setTimeout(doLoad, delay);
      console.log(`[ConsultMap][${name}] Timer ${delay}ms avant chargement static`);
    } else {
      doLoad();
    }
    return;
  }

  // Dynamic layer logic with bounds cache
  const currentMapBounds = map.getBounds();
  
  // Vérifier si une requête est déjà en cours pour cette couche
  if (pendingFetches[name]) {
    console.log(`[ConsultMap][${name}] Requête déjà en cours, skip`);
    return;
  }
  
  // Vérifier le cache de bounds
  if (lastBounds[name] && lastBounds[name].contains(currentMapBounds)) {
    console.log(`[ConsultMap][${name}] Cache hit: emprise courante incluse, pas de refetch`);
    return;
  }
  
  // Clear old layers before fetching new ones
  group.clearLayers();
  lastBounds[name] = expandBounds(currentMapBounds);
  const q = '?' + computeBoundsQuery();
  const fetchLabel = `[${name}] fetch`;
  const parseLabel = `[${name}] parse`;
  const renderLabel = `[${name}] render`;
  
  pendingFetches[name] = true;
  console.time(fetchLabel);
  fetch(cfg.endpoint + q)
    .then(r => { console.timeEnd(fetchLabel); console.time(parseLabel); return r.json(); })
    .then(geo => {
      console.timeEnd(parseLabel); console.time(renderLabel);
      const gj = L.geoJSON(geo, {
        style: cfg.style,
        onEachFeature: (feat, layer) => {
          if (feat.properties){
            const nm = feat.properties.name || feat.properties.nom || name;
            let popupContent = `<strong>${nm}</strong>`;
            // Ajouter un lien d'édition pour les parcs
            if (name === 'Parcs' && feat.properties.id) {
              const sUrlEditPark = window.location.protocol + "//" + window.location.host + urlEditPark + '?idPark=';
              popupContent += `<p><a href='${sUrlEditPark}${feat.properties.id}'>Éditer</a></p>`;
            }
            // Ajouter id et surface pour la Végétation IGN
            if (name === 'Végétation IGN') {
              if (feat.id) {
                popupContent += `<p>ID: ${feat.id}</p>`;
              }
              if (feat.properties.surface) {
                const surface = parseFloat(feat.properties.surface);
                if (surface >= 10000) {
                  const hectares = (surface / 10000).toFixed(2);
                  popupContent += `<p>Surface: ${hectares} ha</p>`;
                } else {
                  const m2 = Math.round(surface);
                  popupContent += `<p>Surface: ${m2} m²</p>`;
                }
              }
            }
            layer.bindPopup(popupContent);
          }
        }
      });
      console.timeEnd(renderLabel);
      group.addLayer(gj);
      pendingFetches[name] = false;
      console.log(`[ConsultMap][${name}] Chargé avec succès`);
    })
    .catch(err => {
      console.warn('Erreur chargement couche', name, err);
      console.timeEnd(fetchLabel); console.timeEnd(parseLabel); console.timeEnd(renderLabel);
      pendingFetches[name] = false;
      // En cas d'erreur, réinitialiser le cache pour permettre une nouvelle tentative
      delete lastBounds[name];
    });
}

function reloadGeojsonLayers() {
  // Ne recharge que les dynamiques
  Object.keys(dataLayers).forEach(name => { if (!overlayConfig[name].static) updateGeojsonLayer(name); });
  console.log('[ConsultMap] reloadGeojsonLayers (dynamiques) appelé');
}

// Fonction pour mettre à jour le lien Google Map
function getGMapUrl(clkLat, clkLng) {
  return "https://www.google.com/maps/@" + clkLat + "," + clkLng + ",18.03z";
}

function updateGMapLink() {
  const b = map.getBounds();
  const gmLat = (b.getNorthEast().lat + b.getSouthWest().lat) / 2;
  const gmLng = (b.getSouthWest().lng + b.getNorthEast().lng) / 2;
  const lnk = getGMapUrl(gmLat, gmLng);
  
  const oGmLink = document.getElementById("aGMapLink");
  if (oGmLink) {
    oGmLink.href = lnk;
    console.log('[ConsultMap] Lien Google Map mis à jour:', lnk);
  }
}

map.on('overlayadd', function(e) {
  if (dataLayers[e.name]) updateGeojsonLayer(e.name);
  console.log('[ConsultMap] overlayadd', e.name);
});
map.on('overlayremove', function(e) {
  if (dataLayers[e.name]) dataLayers[e.name].clearLayers();
  console.log('[ConsultMap] overlayremove', e.name);
});

// Debounce du rechargement des couches (900ms) pour éviter surcharges lors de déplacements successifs
let reloadTimer = null;
function scheduleReload(){
  if (reloadTimer) clearTimeout(reloadTimer);
  reloadTimer = setTimeout(() => {
    reloadGeojsonLayers();
  }, 900);
}
map.on('moveend', scheduleReload);
map.on('zoomend', scheduleReload);
reloadGeojsonLayers();

</script>
</body>
</html>
