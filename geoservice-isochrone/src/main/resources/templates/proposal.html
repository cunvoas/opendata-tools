<!DOCTYPE html>
<html lang="fr" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity6">
<head th:insert="~{fragments/fragment-head :: head}"></head>
<body class="sb-nav-fixed">
<div th:insert="~{fragments/fragment-navUp :: navUp}"></div>
<div id="layoutSidenav">
  <div th:insert="~{fragments/fragment-navLeft :: navLeft}"></div>
  <div id="layoutSidenav_content">
    <main>
      <div class="container-fluid">
        <h4 class="mt-3">Proposition de parcs et jardin</h4>
        <p class="text-muted">Calculer des propositions de parcs pour obtenir un rationrface et densité. La carte permet de visualiser les résultats.</p>


        <!-- Sélecteurs de territoire -->
        <div class="row mb-4">
          <div class="col-12">
            <div class="card border-0 shadow-sm">
              <div class="card-header bg-white border-bottom">
                <h6 class="mb-0">Sélection du territoire</h6>
              </div>
              <div class="card-body">
                <div class="row g-3">
                  <!-- Région Filter -->
                  <div class="col-md-3">
                    <div class="d-flex align-items-center h-100">
                      <form id="formSelectRegion" th:action="@{/mvc/proposal/region}" th:object="${formProposal}" method="post" onchange="submit();" class="w-100">
                        <div class="form-floating">
                          <select class="form-select" id="idRegion" name="idRegion" th:field="*{idRegion}">
                            <option value="" selected disabled>Choisir une région...</option>
                            <option th:each="region : ${regions}" 
                              th:value="${region.id}" 
                              th:text="${region.name}"></option>
                          </select>
                          <label for="idRegion"><i class="fas fa-map me-2"></i>Région</label>
                        </div>
                      </form>
                    </div>
                  </div>
                  <!-- EPCI Filter -->
                  <div class="col-md-3">
                    <div class="d-flex align-items-center h-100">
                      <form id="formSelectComm2co" th:action="@{/mvc/proposal/commDeCo}" th:object="${formProposal}" method="post" onchange="submit();" class="w-100">
                        <fieldset id="fsComm2co" th:disabled="${formProposal.idRegion == null}">
                          <div class="form-floating">
                            <select class="form-select" id="idCommunauteDeCommunes" name="idCommunauteDeCommunes" th:field="*{idCommunauteDeCommunes}">
                              <option value="">EPCI...</option>
                              <option th:each="commDeCo : ${communautesDeCommunes}" 
                                th:value="${commDeCo.id}" 
                                th:text="${commDeCo.name}"></option>
                            </select>
                            <label for="idCommunauteDeCommunes"><i class="fas fa-building me-2"></i>Communauté de communes</label>
                            <input type="hidden" id="idRegionComm" name="idRegion" th:field="*{idRegion}" />
                          </div>
                        </fieldset>
                      </form>
                    </div>
                  </div>
                  <!-- Commune Filter -->
                  <div class="col-md-6">
                    <div class="d-flex align-items-center h-100">
                      <form id="formSelectCity" th:action="@{/mvc/proposal/city}" method="POST" th:object="${formProposal}" class="w-100">
                        <fieldset id="fsCity" th:disabled="${formProposal.idCommunauteDeCommunes == null}">
                          <div class="form-floating">
                            <input class="form-select" list="communes" id="idCommune-filter" name="idCommune-filter" 
                                   th:value="${formProposal.nameCommune}" placeholder="Commune..." />
                            <label for="idCommune-filter"><i class="fas fa-city me-2"></i>Commune</label>
                            <datalist id="communes">
                              <option th:each="commune : ${communes}" 
                                th:value="${commune.name}" 
                                th:attr="data-value=${commune.id},data-insee=${commune.inseeCode}"></option>
                            </datalist>
                            <input type="hidden" id="idCommune" name="idCommune" th:field="*{idCommune}" />
                            <input type="hidden" id="idRegionCity" name="idRegion" th:field="*{idRegion}" />
                            <input type="hidden" id="idCommunauteDeCommunesCity" name="idCommunauteDeCommunes" th:field="*{idCommunauteDeCommunes}" />
                          </div>
                        </fieldset>
                      </form>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>


        <!-- Message d'erreur token invalide -->
        <div class="alert alert-danger" th:if="${tokenInvalid}">
          <i class="fas fa-exclamation-triangle"></i> La soumission a échoué : le formulaire a déjà été soumis ou a expiré. Veuillez réessayer.
        </div>

        <!-- Formulaire de calcul de proposition -->
        <form id="formCompute" th:action="@{/mvc/proposal/compute}" method="post" th:object="${formProposal}">
          <!-- Anti double soumission: token serveur -->
          <input type="hidden" name="token" th:field="*{token}" />
          <input type="hidden" name="id" th:field="*{id}" />
          <input type="hidden" name="idRegion" th:field="*{idRegion}" />
          <input type="hidden" name="idCommunauteDeCommunes" th:field="*{idCommunauteDeCommunes}" />
          <input type="hidden" name="idCommune" th:field="*{idCommune}" />
          <input type="hidden" id="codeInsee" name="codeInsee" th:field="*{codeInsee}" />
          <input type="hidden" id="mapLat" name="mapLat" th:field="*{mapLat}" />
          <input type="hidden" id="mapLng" name="mapLng" th:field="*{mapLng}" />
          <input type="hidden" id="sGeometry" name="sGeometry" />
          <input type="hidden" id="name" name="name" th:value="${formProposal.nameCommune}" />

          <div class="row g-3 mb-3">
            <!-- Colonne gauche : paramètres -->
            <div class="col-12 col-lg-6">
              <div class="card">
                <div class="card-header">Paramètres du calcul</div>
                <div class="card-body">
                  <div class="row g-2">
                    <div class="col-12 col-md-6">
                      <label for="annee" class="form-label">Année</label>
                      <select class="form-select" id="annee" th:field="*{annee}">
                        <option value="" disabled selected>Choisir une année...</option>
                        <option th:each="annee : ${listAnnee}" th:value="${annee}" th:text="${annee}"></option>
                      </select>
                    </div>
                    <div class="col-12 col-md-6">
                      <label for="type" class="form-label">Algorithme</label>
                      <select class="form-select" id="type" th:field="*{type}">
                        <option value="" disabled>Choisir un algorithme...</option>
                        <option th:each="t : ${typeCalcul}" th:value="${t}" th:text="${t.displayName}"></option>
                      </select>
                    </div>
                  </div>

                  <div class="row g-2 mt-3">
                    <div class="col-12">
                      <label class="form-label">Contexte</label>
                      <div class="form-control-plaintext">
                        <span th:text="${formProposal.nameCommune != null ? formProposal.nameCommune : 'Commune non sélectionnée'}"></span>
                        <span th:if="${formProposal.nameCommunauteDeCommunes != null}" class="text-muted">
                          • EPCI: <span th:text="${formProposal.nameCommunauteDeCommunes}"></span>
                        </span>
                      </div>
                    </div>
                  </div>

                  <div class="row mt-3">
                    <div class="col-12">
                      <button type="submit" class="btn btn-primary w-100" th:disabled="${formProposal.idCommune == null}">
                        <i class="fas fa-calculator"></i> Lancer le calcul
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Colonne droite : liste des propositions -->
            <div class="col-12 col-lg-6">
              <div class="card">
                <div class="card-header">
                  <h6 class="mb-0">
                    <i class="fas fa-list me-2"></i>Propositions pour <span th:text="${formProposal.nameCommune != null ? formProposal.nameCommune : 'la commune'}"></span>
                  </h6>
                </div>
                <div class="card-body">
                  <!-- Message si pas de propositions -->
                  <div th:if="${propositions == null || propositions.isEmpty()}" class="text-muted text-center py-4">
                    <i class="fas fa-info-circle me-2"></i>Aucune proposition disponible pour cette commune.
                    <br>
                    <small>Sélectionnez une commune et lancez le calcul pour générer des propositions.</small>
                  </div>
                  
                  <!-- Liste des propositions -->
                  <div th:if="${propositions != null && !propositions.isEmpty()}">
                    <div class="table-responsive" style="max-height: 350px; overflow-y: auto;">
                      <table class="table table-sm table-hover">
                        <thead class="table-light sticky-top">
                          <tr>
                            <th style="cursor: pointer;" onclick="sortPropositionsTable('annee')">
                              Année <i id="sortIcon-annee" class="fas fa-sort"></i>
                            </th>
                            <th style="cursor: pointer;" onclick="sortPropositionsTable('typeAlgo')">
                              Algorithme <i id="sortIcon-typeAlgo" class="fas fa-sort"></i>
                            </th>
                            <th class="text-end" style="cursor: pointer;" onclick="sortPropositionsTable('numberOfParks')">
                              Nb parcs <i id="sortIcon-numberOfParks" class="fas fa-sort"></i>
                            </th>
                            <th class="text-end" style="cursor: pointer;" onclick="sortPropositionsTable('totalSurfaceOfParks')">
                              Surface (m²) <i id="sortIcon-totalSurfaceOfParks" class="fas fa-sort"></i>
                            </th>
                            <th class="text-center">Actions</th>
                          </tr>
                        </thead>
                        <tbody id="propositionsTableBody">
                          <tr th:each="prop : ${propositions}" class="proposition-row" 
                              th:attr="data-annee=${prop.annee},data-type-algo=${prop.typeAlgo?.displayName},data-number-of-parks=${prop.numberOfParks},data-total-surface-of-parks=${prop.totalSurfaceOfParks}">
                            <td th:text="${prop.annee}">2023</td>
                            <td th:text="${prop.typeAlgo?.displayName}">Algorithme</td>
                            <td class="text-end" th:text="${prop.numberOfParks}">0</td>
                            <td class="text-end" th:text="${#numbers.formatDecimal(prop.totalSurfaceOfParks, 0, 0)}">1000</td>
                            <td class="text-center">
                              <button type="button" class="btn btn-sm btn-outline-primary" onclick="viewProposition(this)" 
                                      th:attr="data-id=${prop.id},data-insee=${prop.insee},data-annee=${prop.annee},data-type=${prop.typeAlgo}">
                                <i class="fas fa-eye"></i>
                              </button>
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                    
                    <!-- Pagination pour les propositions -->
                    <div id="propositionsPaginationContainer" class="d-flex justify-content-between align-items-center mt-2">
                      <button id="prevPropositionsPage" class="btn btn-sm btn-outline-secondary" onclick="changePropositionsPage(-1)">
                        <i class="fas fa-chevron-left"></i> Précédent
                      </button>
                      <span id="propositionsPaginationInfo" class="text-muted small">Page 1 / 1</span>
                      <button id="nextPropositionsPage" class="btn btn-sm btn-outline-secondary" onclick="changePropositionsPage(1)">
                        Suivant <i class="fas fa-chevron-right"></i>
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Carte en dessous -->
          <div class="row g-3 mb-3">
            <div class="col-12 map-block">
              <div class="card">
                <div class="card-header">Carte des propositions</div>
                <div class="card-body p-0">
                  <div id="mapSimulator" style="width:100%; height:600px;"></div>
                </div>
                <div class="card-footer text-muted small">
                  Les propositions calculées s'affichent sur la carte.
                </div>
              </div>
            </div>
          </div>
        </form>


          

      </div>
    </main>
  </div>
</div>

<div th:insert="~{fragments/fragment-footer :: footer}"></div>
<div th:insert="~{fragments/fragment-jslibs :: newMap}"></div>
<script th:src="@{/mvc/static/js/scripts.js}"></script>

<style>
  .below-oms-threshold {
    background-color: #ffcccc !important;
  }
  .above-oms-threshold {
    background-color: #ccffcc !important;
  }

  .print-button-fixed {
    position: fixed;
    top: 70px;
    right: 24px;
    z-index: 1100;
  }
  
  /* Style pour le tableau des propositions */
  .proposition-row {
    cursor: pointer;
    transition: background-color 0.2s;
  }
  
  .proposition-row:hover {
    background-color: rgba(0, 123, 255, 0.1);
  }
  
  .table-responsive {
    scrollbar-width: thin;
    scrollbar-color: rgba(0, 0, 0, 0.3) transparent;
  }
  
  .table-responsive::-webkit-scrollbar {
    width: 8px;
  }
  
  .table-responsive::-webkit-scrollbar-track {
    background: transparent;
  }
  
  .table-responsive::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
  }
  
  .sticky-top {
    position: sticky;
    top: 0;
    z-index: 10;
  }

  @media print {
    @page {
      margin: 0;
    }

    /* Masquer navigation, boutons, pagination et formulaires de sélection */
    .sb-nav-fixed nav,
    #layoutSidenav > div:first-child,
    #layoutSidenav #layoutSidenav_nav,
    .sb-sidenav,
    .card-header .btn,
    #paginationContainer,
    .pagination,
    button,
    .btn,
    form#formSelectRegion,
    form#formSelectComm2co,
    form#formSelectCity,
    #formCompute button {
      display: none !important;
    }

    /* Masquer le bloc des projets existants de la commune */
    .projects-existing {
      display: none !important;
    }

    /* Masquer les sélecteurs Région / EPCI / Commune */
    .territory-select {
      display: none !important;
    }

    /* Saut de page avant la carte */
    .map-block {
      page-break-before: always;
    }

    /* Saut de page avant le tableau de résultats */
    .results-block {
      page-break-before: always;
    }

    /* Afficher toutes les lignes de tableaux (pas de pagination) */
    #projectsTableBody .project-row,
    #projectWorkTableBody tr {
      display: table-row !important;
    }

    /* Désactiver le scroll pour imprimer tout le contenu */
    .table-responsive {
      overflow: visible !important;
      max-height: none !important;
    }

    /* Carte imprimable avec taille fixe et sans contrôles Leaflet */
    #mapSimulator {
      height: 600px !important;
    }
    .leaflet-control-container,
    .leaflet-top,
    .leaflet-bottom {
      display: none !important;
    }

    /* Masquer la ligne licence / conditions du footer */
    footer {
      display: none !important;
    }

    /* Supprimer les marges/gouttières pour éviter la bande blanche gauche */
    body {
      margin: 0 !important;
      padding: 0 !important;
      padding-left: 10mm !important;
      padding-right: 10mm !important;
      box-sizing: border-box !important;
      width: 100% !important;
      min-width: 100% !important;
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
      font-size: 12px;
    }
    #layoutSidenav {
      display: block !important;
      width: 100% !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    #layoutSidenav_content {
      margin-left: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      padding-top: 0 !important;
      width: 100% !important;
    }
    main,
    .container-fluid {
      padding-left: 0 !important;
      padding-right: 0 !important;
      margin: 0 !important;
      width: 100% !important;
    }
    /* Forcer le body et les wrappers à ne pas réserver d'espace caché */
    #layoutSidenav_content > main {
      margin: 0 !important;
      padding: 0 !important;
      width: 100% !important;
    }

    /* Conserver les couleurs d'arrière-plan à l'impression */
  }
</style>

<script th:inline="javascript">

// ----------- CONFIGURATION CARTE -----------
const mapMinZoom = 10;
const mapMaxZoom = 18;
const zoomInit = 15;

// Coordonnées par défaut
const latInit = 50.626419;
const lonInit = 3.0719121;

// ----------- FONDS DE CARTE -----------
const layerOSM = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; <a target="_blank" rel="noopener" href="http://osm.org/copyright">OpenStreetMap</a> contributors',
  maxZoom: mapMaxZoom,
  minZoom: mapMinZoom
});

const layerSatellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Esri Satellite',
  maxZoom: mapMaxZoom,
  minZoom: mapMinZoom
});

const layerAeroIgn = L.tileLayer('https://data.geopf.fr/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE=normal&TILEMATRIXSET=PM&FORMAT=image/jpeg&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&LAYER=ORTHOIMAGERY.ORTHOPHOTOS', {
  attribution: 'IGN GeoPortail',
  maxZoom: Math.min(18, mapMaxZoom),
  minZoom: mapMinZoom
});

const baseLayers = {
  'IGN Aérien': layerAeroIgn,
  'Satellite': layerSatellite,
  'OpenStreetMap': layerOSM
};

const overlays = {};


// custom location on load
function locatePlace(lat, lon) {
  return L.latLng(parseFloat(lat), parseFloat(lon));
}

// Déterminer la position de la carte
function getMapLocation() {
  const mLat = document.getElementById("mapLat").value;
  const mLng = document.getElementById("mapLng").value;
  console.log('[Simulateur] Coordonnées du formulaire - lat:', mLat, 'lng:', mLng);

  let locateWorkPlace;

  // Utiliser les coordonnées du formulaire si disponibles
  if (mLat && mLng && mLat.trim() !== "" && mLng.trim() !== "" && !isNaN(parseFloat(mLat)) && !isNaN(parseFloat(mLng))) {
    locateWorkPlace = locatePlace(mLat, mLng);
    console.log('[Simulateur] Position personnalisée:', locateWorkPlace);
  }
  // Position par défaut
  else {
    locateWorkPlace = L.latLng(latInit, lonInit);
    console.log('[Simulateur] Position par défaut:', locateWorkPlace);
  }
  
  return locateWorkPlace;
}

let locateWorkPlace = getMapLocation();


// ----------- INITIALISATION CARTE -----------
// Stocker les coordonnées cibles
const targetLat = locateWorkPlace.lat;
const targetLng = locateWorkPlace.lng;
console.log('[Simulateur] Initialisation carte, position:', targetLat, targetLng);

const map = L.map('mapSimulator', {
    center: [targetLat, targetLng],
    zoom: zoomInit,
    layers: [layerOSM],
    keyboard: false
});

console.log('[Simulateur] Centre de la carte après init:', map.getCenter());

// Forcer le recentrage après que le DOM soit stable
setTimeout(function() {
  window.scrollTo(0, 0);
  map.invalidateSize();
  map.setView([targetLat, targetLng], zoomInit, { animate: false, reset: true });
  console.log('[Simulateur] Recentrage forcé sur:', targetLat, targetLng, '- Centre actuel:', map.getCenter());
}, 200);


// ----------- OVERLAYS DYNAMIQUES -----------
const dataParcs = L.layerGroup().addTo(map);
const dataProjectZone = L.layerGroup().addTo(map);
const dataProjectWork = L.layerGroup(); // Layer pour les propositions, non affiché par défaut

overlays['Parcs existants'] = dataParcs;
overlays['Projets'] = dataProjectZone;

L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);


// Légende des états de parcs (couleurs alignées avec consultMap)
const legend = L.control({ position: 'bottomright' });
legend.onAdd = function () {
  const div = L.DomUtil.create('div', 'info legend');
  div.style.background = 'white';
  div.style.padding = '8px';
  div.style.borderRadius = '4px';
  div.style.boxShadow = '0 0 8px rgba(0,0,0,0.2)';
  const labels = [];
  labels.push(`<i style="background:#3aa637;width:18px;height:18px;display:inline-block;margin-right:6px;"></i> Parc inclus OMS`);
  labels.push(`<i style="background:#e96020;width:18px;height:18px;display:inline-block;margin-right:6px;"></i> Parc exclus OMS`);
  labels.push(`<i style="background:#DC20E9;width:18px;height:18px;display:inline-block;margin-right:6px;"></i> Parc futur ou détruit`);
  labels.push(`<i style="background:#66ff66;width:18px;height:18px;display:inline-block;margin-right:6px;"></i> Carreaux ≥ 10 m²/hab`);
  labels.push(`<i style="background:#ff6666;width:18px;height:18px;display:inline-block;margin-right:6px;"></i> Carreaux < 10 m²/hab`);
  div.innerHTML = labels.join('<br>');
  return div;
};
legend.addTo(map);

// ----------- CHARGEMENT PARCS -----------
const endpointParcs = /*[[@{/mvc/geojson/parkGardenOutlineByCorner}]]*/ '';
const endpointProjects = /*[[@{/mvc/geojson/projectByCorner}]]*/ '';
const endpointProjectWork = /*[[@{/mvc/geojson/projectWorkById}]]*/ '';

/**
 * Détermine le style dynamique d'un parc en fonction de ses propriétés
 */
function getParkStyle(feature) {
  let fillColor = '#3aa637'; // Couleur par défaut (parc inclus OMS)
  
  if (feature && feature.properties) {
    // Vérifier d'abord si le parc est actif
    if (feature.properties.actif === false) {
      fillColor = '#DC20E9'; // Futur parc ou détruit
    } else if (feature.properties.oms === false) {
      fillColor = '#e96020'; // Parc exclus OMS
    } else if (feature.properties.oms === true) {
      fillColor = '#3aa637'; // Parc inclus OMS
    }
  }
  
  return { color: '#1e4d1c', fillColor, weight: 1, fillOpacity: 0.35 };
}

/**
 * Charge les parcs dans la zone visible
 */
function loadParcs() {
  if (!endpointParcs) return;
  
  const b = map.getBounds();
  const url = `${endpointParcs}?swLat=${b.getSouthWest().lat}&swLng=${b.getSouthWest().lng}&neLat=${b.getNorthEast().lat}&neLng=${b.getNorthEast().lng}`;
  
  fetch(url)
    .then(r => r.json())
    .then(geojson => {
      dataParcs.clearLayers();
      L.geoJSON(geojson, {
        style: function(feature) { return getParkStyle(feature); },
        onEachFeature: function(feature, layer) {
          if (feature.properties && feature.properties.name) {
            layer.bindPopup('<b>' + feature.properties.name + '</b>');
          }
          // Ajouter une classe CSS pour identifier les parcs
          layer._isParc = true;
        }
      }).addTo(dataParcs);
      console.log('[Simulateur] Parcs chargés:', geojson.features ? geojson.features.length : 0);
    })
    .catch(err => console.error('[Simulateur] Erreur chargement parcs', err));
}

/**
 * Charge les projets de simulation dans la zone visible
 */
function loadProjects() {
  if (!endpointProjects) return;
  
  const b = map.getBounds();
  const url = `${endpointProjects}?swLat=${b.getSouthWest().lat}&swLng=${b.getSouthWest().lng}&neLat=${b.getNorthEast().lat}&neLng=${b.getNorthEast().lng}`;
  
  fetch(url)
    .then(r => r.json())
    .then(geojson => {
      dataProjectZone.clearLayers();
      
      // Re-add current layer if it exists
      if (currentLayer) {
        currentLayer.addTo(dataProjectZone);
      }
      
      L.geoJSON(geojson, {
        style: function(feature) {
          return {
            color: '#0066cc',
            fillColor: '#3399ff',
            weight: 2,
            fillOpacity: 0.25
          };
        },
        onEachFeature: function(feature, layer) {
          let popupContent = '';
          let projectName = '';
          if (feature.properties && feature.properties.name) {
            projectName = feature.properties.name;
            popupContent = '<b>' + feature.properties.name + '</b><br>';
          } else {
            popupContent = '<b>Projet de simulation</b><br>';
          }
          if (feature.properties) {
            if (feature.properties.annee) popupContent += 'Année: ' + feature.properties.annee + '<br>';
            if (feature.properties.population) popupContent += 'Population: ' + feature.properties.population + '<br>';
            if (feature.properties.surfaceArea) popupContent += 'Surface: ' + Math.round(feature.properties.surfaceArea) + ' m²<br>';
          }
          // Afficher les infos du projet au clic sur la forme (comme les parcs)
          layer.bindPopup(popupContent);
        }
      }).addTo(dataProjectZone);
      console.log('[Simulateur] Projets chargés:', geojson.features ? geojson.features.length : 0);
    })
    .catch(err => console.error('[Simulateur] Erreur chargement projets', err));
}

/**
 * Charge les éléments du projet (ProjectWork) pour le projet en cours
 */
function loadProjectWork() {
  if (!endpointProjectWork) return;
  
  // Récupérer l'ID du projet depuis le formulaire
  const projectId = document.getElementById('id').value;
  if (!projectId || projectId.trim() === '') {
    dataProjectWork.clearLayers();
    return;
  }
  
  const url = `${endpointProjectWork}?id=${projectId}`;
  
  fetch(url)
    .then(r => r.json())
    .then(geojson => {
      dataProjectWork.clearLayers();
      
      L.geoJSON(geojson, {
        style: function(feature) {
          // Couleur basée sur newSurfacePerCapita par rapport au seuil OMS (10 m²/hab)
          let fillColor = '#cccccc'; // Gris par défaut si pas de valeur
          let borderColor = '#666666';
          
          if (feature.properties && feature.properties.newSurfacePerCapita !== null && feature.properties.newSurfacePerCapita !== undefined) {
            if (feature.properties.newSurfacePerCapita < 10) {
              // Rouge si sous le seuil OMS
              fillColor = '#ff6666';
              borderColor = '#cc0000';
            } else {
              // Vert si au-dessus du seuil OMS
              fillColor = '#66ff66';
              borderColor = '#00cc00';
            }
          }
          
          return {
            color: borderColor,
            fillColor: fillColor,
            weight: 2,
            fillOpacity: 0.5
          };
        },
        onEachFeature: function(feature, layer) {
          let popupContent = '';
          if (feature.properties) {
            popupContent += '<b>Carré INSEE: ' + (feature.properties.idInspire || 'N/A') + '</b><br>';
            if (feature.properties.localPopulation) {
              popupContent += 'Population locale: ' + Math.round(feature.properties.localPopulation) + '<br>';
            }
            if (feature.properties.accessingPopulation) {
              popupContent += 'Population accès: ' + Math.round(feature.properties.accessingPopulation) + '<br>';
            }
            if (feature.properties.accessingSurface) {
              popupContent += 'Surface accès: ' + Math.round(feature.properties.accessingSurface) + ' m²<br>';
            }
            if (feature.properties.surfacePerCapita) {
              popupContent += 'Surface/hab: ' + Math.round(feature.properties.surfacePerCapita * 100) / 100 + ' m²<br>';
            }
            if (feature.properties.newSurfacePerCapita) {
              popupContent += 'Nouvelle surf/hab: ' + Math.round(feature.properties.newSurfacePerCapita * 100) / 100 + ' m²';
            }
          }
          layer.bindPopup(popupContent);
          
          // Marquer comme projectWork
          layer._isProjectWork = true;
        }
      }).addTo(dataProjectWork);
      console.log('[Simulateur] ProjectWork chargés:', geojson.features ? geojson.features.length : 0);
    })
    .catch(err => console.error('[Simulateur] Erreur chargement projectWork', err));
}

// Chargement initial et au déplacement
map.on('moveend', function() {
  loadParcs();
  loadProjects();
});
loadParcs();
loadProjects();
// Ne pas charger loadProjectWork() au démarrage, sera chargé par le bouton de visualisation

console.log('[Simulateur] Carte initialisée');

// ----------- GESTION DATALIST COMMUNES -----------
(function initCommuneDatalist(){
  const input = document.getElementById('idCommune-filter');
  if (!input) return;
  
  console.log('[Simulateur] Init datalist commune');
  
  input.addEventListener('input', function(e){
    const options = document.querySelectorAll('#communes option');
    const hiddenInput = document.getElementById('idCommune');
    const inseeInput = document.getElementById('codeInsee');
    const inputValue = e.target.value;
    
    console.log('[Simulateur] Input commune changed:', inputValue);
    
    hiddenInput.value = '';
    if (inseeInput) {
      inseeInput.value = '';
    }
    
    for (const o of options){
      if (o.value === inputValue) {
        const dataValue = o.getAttribute('data-value');
        const dataInsee = o.getAttribute('data-insee');
        hiddenInput.value = dataValue;
        if (inseeInput) {
          inseeInput.value = dataInsee || '';
        }
        console.log('[Simulateur] Commune trouvée, id:', dataValue);
        document.getElementById('formSelectCity').submit();
        break;
      }
    }
  });
})();

// ----------- CALCUL AUTOMATIQUE POPULATION -----------
(function initAutoPopulation(){
  const floorEl = document.getElementById('surfaceFloor');
  const avgEl = document.getElementById('avgAreaAccommodation');
  const densityEl = document.getElementById('densityPerAccommodation');
  const populationEl = document.getElementById('population');

  if (!floorEl || !avgEl || !densityEl || !populationEl) return;

  const computePopulation = () => {
    const floor = parseFloat(floorEl.value);
    const avg = parseFloat(avgEl.value);
    const density = parseFloat(densityEl.value);
    if (isNaN(floor) || isNaN(avg) || isNaN(density) || avg === 0) {
      return;
    }
    const pop = (floor / avg) * density;
    populationEl.value = Math.round(pop);
  };

  ['input', 'change'].forEach(evt => {
    floorEl.addEventListener(evt, computePopulation);
    avgEl.addEventListener(evt, computePopulation);
    densityEl.addEventListener(evt, computePopulation);
  });

  computePopulation();
})();

// Fonction pour effacer le formulaire et créer un nouveau projet
function clearProjectForm() {
  console.log('[Simulateur] clearProjectForm() appelée');
  
  // Effacer les champs du formulaire
  document.getElementById('id').value = '';
  document.getElementById('name').value = '';
  document.getElementById('annee').value = '';
  document.getElementById('isDense').checked = false;
  document.getElementById('densityPerAccommodation').value = '';
  document.getElementById('avgAreaAccommodation').value = '';
  document.getElementById('surfaceFloor').value = '';
  document.getElementById('population').value = '';
  document.getElementById('surfaceArea').value = '';
  document.getElementById('surfacePark').value = '';
  document.getElementById('sGeometry').value = '';
  
  // Effacer la géométrie de la carte
  if (currentLayer) {
    dataProjectZone.removeLayer(currentLayer);
    currentLayer = null;
  }
  
  // Supprimer le label du projet
  if (projectLabel) {
    map.removeLayer(projectLabel);
    projectLabel = null;
  }
  
  // Effacer les projectWork de la carte
  dataProjectWork.clearLayers();
  
  console.log('[Simulateur] Formulaire effacé');
}

// Fonction pour calculer la simulation (comme savePark dans newPark.html)
function computeSimulation() {
  console.log('[Simulateur] computeSimulation() appelée');
  
  // Récupérer les couches dessinées pour s'assurer que sGeometry est à jour
  const self_drawn = map.pm.getGeomanDrawLayers(true);
  const strPoly = JSON.stringify(self_drawn.toGeoJSON());
  document.getElementById('sGeometry').value = strPoly;
  
  // Récupérer le formulaire et le soumettre normalement
  const form = document.getElementById('formCompute');
  form.submit();
}


// ----------- PAGINATION ET TRI DU TABLEAU PROJETS -----------
let currentPage = 1;
const itemsPerPage = 4;
let sortAscending = true;

function initProjectsTable() {
  const rows = document.querySelectorAll('#projectsTableBody .project-row');
  if (rows.length === 0) return;
  
  updatePagination();
}

function updatePagination() {
  const rows = Array.from(document.querySelectorAll('#projectsTableBody .project-row'));
  const totalRows = rows.length;
  const totalPages = Math.ceil(totalRows / itemsPerPage);
  
  if (totalRows === 0) {
    document.getElementById('paginationContainer')?.classList.add('d-none');
    return;
  }
  
  // Afficher/masquer les lignes selon la page courante
  rows.forEach((row, index) => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    row.style.display = (index >= startIndex && index < endIndex) ? '' : 'none';
  });
  
  // Mettre à jour l'info de pagination
  const paginationInfo = document.getElementById('paginationInfo');
  if (paginationInfo) {
    paginationInfo.textContent = `Page ${currentPage} / ${totalPages}`;
  }
  
  // Gérer l'état des boutons précédent/suivant
  const prevPage = document.getElementById('prevPage');
  const nextPage = document.getElementById('nextPage');
  if (prevPage) prevPage.classList.toggle('disabled', currentPage === 1);
  if (nextPage) nextPage.classList.toggle('disabled', currentPage === totalPages);
}

function changePage(delta) {
  const rows = document.querySelectorAll('#projectsTableBody .project-row');
  const totalPages = Math.ceil(rows.length / itemsPerPage);
  
  const newPage = currentPage + delta;
  if (newPage >= 1 && newPage <= totalPages) {
    currentPage = newPage;
    updatePagination();
  }
}

function sortProjectsTable() {
  const tbody = document.getElementById('projectsTableBody');
  const rows = Array.from(tbody.querySelectorAll('.project-row'));
  const sortIcon = document.getElementById('sortIcon');
  
  if (rows.length === 0) return;
  
  // Trier les lignes par nom
  rows.sort((a, b) => {
    const nameA = (a.dataset.name || '').toLowerCase();
    const nameB = (b.dataset.name || '').toLowerCase();
    return sortAscending ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
  });
  
  // Réorganiser les lignes dans le tbody
  rows.forEach(row => tbody.appendChild(row));
  
  // Inverser le sens du tri pour le prochain clic
  sortAscending = !sortAscending;
  
  // Mettre à jour l'icône
  if (sortIcon) {
    sortIcon.className = sortAscending ? 'fas fa-sort-down' : 'fas fa-sort-up';
  }
  
  // Revenir à la première page après tri
  currentPage = 1;
  updatePagination();
}

// Initialiser le tableau au chargement
initProjectsTable();

// ----------- TRI DU TABLEAU DES PROPOSITIONS -----------
let propositionsSortColumn = null;
let propositionsSortAscending = true;
let currentPropositionsPage = 1;
const itemsPerPropositionsPage = 5;

function initPropositionsTable() {
  const rows = document.querySelectorAll('#propositionsTableBody .proposition-row');
  if (rows.length === 0) return;
  
  updatePropositionsPagination();
}

function updatePropositionsPagination() {
  const rows = Array.from(document.querySelectorAll('#propositionsTableBody .proposition-row'));
  const totalRows = rows.length;
  const totalPages = Math.ceil(totalRows / itemsPerPropositionsPage);
  
  if (totalRows === 0) {
    document.getElementById('propositionsPaginationContainer')?.classList.add('d-none');
    return;
  }
  
  // Afficher/masquer les lignes selon la page courante
  rows.forEach((row, index) => {
    const startIndex = (currentPropositionsPage - 1) * itemsPerPropositionsPage;
    const endIndex = startIndex + itemsPerPropositionsPage;
    row.style.display = (index >= startIndex && index < endIndex) ? '' : 'none';
  });
  
  // Mettre à jour l'info de pagination
  const paginationInfo = document.getElementById('propositionsPaginationInfo');
  if (paginationInfo) {
    paginationInfo.textContent = `Page ${currentPropositionsPage} / ${totalPages}`;
  }
  
  // Gérer l'état des boutons précédent/suivant
  const prevPage = document.getElementById('prevPropositionsPage');
  const nextPage = document.getElementById('nextPropositionsPage');
  if (prevPage) prevPage.classList.toggle('disabled', currentPropositionsPage === 1);
  if (nextPage) nextPage.classList.toggle('disabled', currentPropositionsPage === totalPages);
  
  // Afficher/masquer le conteneur de pagination
  const paginationContainer = document.getElementById('propositionsPaginationContainer');
  if (paginationContainer) {
    paginationContainer.classList.toggle('d-none', totalPages <= 1);
  }
}

function changePropositionsPage(delta) {
  const rows = document.querySelectorAll('#propositionsTableBody .proposition-row');
  const totalPages = Math.ceil(rows.length / itemsPerPropositionsPage);
  
  const newPage = currentPropositionsPage + delta;
  if (newPage >= 1 && newPage <= totalPages) {
    currentPropositionsPage = newPage;
    updatePropositionsPagination();
  }
}

function sortPropositionsTable(column) {
  const tbody = document.getElementById('propositionsTableBody');
  if (!tbody) return;
  
  const rows = Array.from(tbody.querySelectorAll('tr'));
  if (rows.length === 0) return;
  
  // Si on clique sur la même colonne, inverser l'ordre
  if (propositionsSortColumn === column) {
    propositionsSortAscending = !propositionsSortAscending;
  } else {
    propositionsSortColumn = column;
    propositionsSortAscending = true;
  }
  
  // Trier les lignes
  rows.sort((a, b) => {
    let valueA, valueB;
    
    if (column === 'annee' || column === 'numberOfParks' || column === 'totalSurfaceOfParks') {
      // Colonnes numériques
      const dataKey = column.replace(/([A-Z])/g, '-$1').toLowerCase();
      valueA = parseFloat(a.getAttribute('data-' + dataKey) || 0);
      valueB = parseFloat(b.getAttribute('data-' + dataKey) || 0);
      return propositionsSortAscending ? valueA - valueB : valueB - valueA;
    } else if (column === 'typeAlgo') {
      // Colonne texte
      valueA = (a.getAttribute('data-type-algo') || '').toLowerCase();
      valueB = (b.getAttribute('data-type-algo') || '').toLowerCase();
      return propositionsSortAscending ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
    }
  });
  
  // Réorganiser les lignes dans le tbody
  rows.forEach(row => tbody.appendChild(row));
  
  // Mettre à jour les icônes de tri
  document.querySelectorAll('[id^="sortIcon-"]').forEach(icon => {
    icon.className = 'fas fa-sort';
  });
  
  const sortIcon = document.getElementById('sortIcon-' + column);
  if (sortIcon) {
    sortIcon.className = propositionsSortAscending ? 'fas fa-sort-up' : 'fas fa-sort-down';
  }
  
  // Revenir à la première page après tri
  currentPropositionsPage = 1;
  updatePropositionsPagination();
  
  console.log('[Propositions] Tableau trié par', column, propositionsSortAscending ? 'ASC' : 'DESC');
}

// Initialiser la pagination des propositions au chargement
initPropositionsTable();

// ----------- VISUALISER UNE PROPOSITION -----------
function viewProposition(button) {
  const propositionId = button.getAttribute('data-id');
  const propositionInsee = button.getAttribute('data-insee');
  const propositionAnnee = button.getAttribute('data-annee');
  
  console.log('[Simulateur] Visualisation de la proposition:', propositionId, 'INSEE:', propositionInsee, 'Année:', propositionAnnee);
  
  if (!propositionId) {
    console.error('[Simulateur] ID de proposition manquant');
    return;
  }
  
  // Effacer les données précédentes
  dataProjectWork.clearLayers();
  
  // Charger les données de la proposition
  if (endpointProjectWork) {
    const url = `${endpointProjectWork}?id=${propositionId}`;
    
    fetch(url)
      .then(r => r.json())
      .then(geojson => {
        if (geojson && geojson.features && geojson.features.length > 0) {
          L.geoJSON(geojson, {
            style: function(feature) {
              // Couleur basée sur newSurfacePerCapita par rapport au seuil OMS (10 m²/hab)
              let fillColor = '#cccccc';
              let borderColor = '#666666';
              
              if (feature.properties && feature.properties.newSurfacePerCapita !== null && feature.properties.newSurfacePerCapita !== undefined) {
                if (feature.properties.newSurfacePerCapita < 10) {
                  fillColor = '#ff6666';
                  borderColor = '#cc0000';
                } else {
                  fillColor = '#66ff66';
                  borderColor = '#00cc00';
                }
              }
              
              return {
                color: borderColor,
                fillColor: fillColor,
                weight: 2,
                fillOpacity: 0.5
              };
            },
            onEachFeature: function(feature, layer) {
              let popupContent = '';
              if (feature.properties) {
                popupContent += '<b>Carré INSEE: ' + (feature.properties.idInspire || 'N/A') + '</b><br>';
                if (feature.properties.localPopulation) {
                  popupContent += 'Population locale: ' + Math.round(feature.properties.localPopulation) + '<br>';
                }
                if (feature.properties.accessingPopulation) {
                  popupContent += 'Population accès: ' + Math.round(feature.properties.accessingPopulation) + '<br>';
                }
                if (feature.properties.accessingSurface) {
                  popupContent += 'Surface accès: ' + Math.round(feature.properties.accessingSurface) + ' m²<br>';
                }
                if (feature.properties.surfacePerCapita) {
                  popupContent += 'Surface/hab: ' + Math.round(feature.properties.surfacePerCapita * 100) / 100 + ' m²<br>';
                }
                if (feature.properties.newSurfacePerCapita) {
                  popupContent += 'Nouvelle surf/hab: ' + Math.round(feature.properties.newSurfacePerCapita * 100) / 100 + ' m²';
                }
              }
              layer.bindPopup(popupContent);
              layer._isProjectWork = true;
            }
          }).addTo(dataProjectWork);
          
          // Ajouter le layer à la carte
          dataProjectWork.addTo(map);
          
          console.log('[Simulateur] Proposition chargée:', geojson.features.length, 'éléments');
        } else {
          console.warn('[Simulateur] Aucune donnée pour la proposition', propositionId);
          alert('Aucune donnée disponible pour cette proposition');
        }
      })
      .catch(err => {
        console.error('[Simulateur] Erreur chargement proposition', err);
        alert('Erreur lors du chargement de la proposition');
      });
  } else {
    alert('Endpoint non configuré pour le chargement des propositions');
  }
}

// ----------- TRI DU TABLEAU DE RÉSULTATS -----------
let projectWorkSortColumn = null;
let projectWorkSortAscending = true;

function sortProjectWorkTable(column) {
  const tbody = document.getElementById('projectWorkTableBody');
  if (!tbody) return;
  
  const rows = Array.from(tbody.querySelectorAll('tr'));
  if (rows.length === 0) return;
  
  // Si on clique sur la même colonne, inverser l'ordre
  if (projectWorkSortColumn === column) {
    projectWorkSortAscending = !projectWorkSortAscending;
  } else {
    projectWorkSortColumn = column;
    projectWorkSortAscending = true;
  }
  
  // Trier les lignes
  rows.sort((a, b) => {
    let valueA, valueB;
    
    if (column === 'name') {
      valueA = (a.dataset.name || '').toLowerCase();
      valueB = (b.dataset.name || '').toLowerCase();
      return projectWorkSortAscending ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
    } else {
      // Pour les colonnes numériques
      const dataKey = column.replace(/([A-Z])/g, '-$1').toLowerCase();
      valueA = parseFloat(a.dataset[column.replace(/([A-Z])/g, (m) => '-' + m.toLowerCase()).substring(column.startsWith('data-') ? 0 : 5)] || a.getAttribute('data-' + dataKey.replace('data-', '')) || 0);
      valueB = parseFloat(b.dataset[column.replace(/([A-Z])/g, (m) => '-' + m.toLowerCase()).substring(column.startsWith('data-') ? 0 : 5)] || b.getAttribute('data-' + dataKey.replace('data-', '')) || 0);
      return projectWorkSortAscending ? valueA - valueB : valueB - valueA;
    }
  });
  
  // Réorganiser les lignes dans le tbody
  rows.forEach(row => tbody.appendChild(row));
  
  // Mettre à jour les icônes de tri
  document.querySelectorAll('[id^="sortIcon-"]').forEach(icon => {
    icon.className = 'fas fa-sort';
  });
  
  const sortIcon = document.getElementById('sortIcon-' + column);
  if (sortIcon) {
    sortIcon.className = projectWorkSortAscending ? 'fas fa-sort-up' : 'fas fa-sort-down';
  }
  
  console.log('[Simulateur] Tableau trié par', column, projectWorkSortAscending ? 'ASC' : 'DESC');
}


</script>

</body>
</html>


